<?php
/*
Задание 1
Какие типы паттернов проектирования существуют?

1. Основные шаблоны (Fundamental)
2. Порождающие шаблоны проектирования (Creational) — шаблоны проектирования, которые абстрагируют процесс инстанцирования. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять инстанцируемый класс, а шаблон, порождающий объекты, делегирует инстанцирование другому объекту
3. Структурные шаблоны проектирования (Structural) — определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.
3. Поведенческие шаблоны проектирования (Behavioral) — определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

Задание 2
Как можно улучшить Singleton при помощи trait-ов?

Получить внутри вызываемого метода название класса, к которому он был вызван, а затем в качестве хранилища воспользоваться отдельным классом со статическим методом.

Задание 3
Как реализуется паттерн Фабричный метод? В чем его отличие от паттерна Фабрика?

Фабричный метод — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне. 

В объектно-ориентированном программировании, фабрика — это объект для создания других объектов. Формально фабрика — это функция или метод, который возвращает объекты изменяющегося прототипа или класса из некоторого вызова метода, который считается «новым».

Задание 4
Объясните назначение и применение магических методов __get, __set, __isset, __unset, __call и __callStatic. Когда, как и почему их стоит использовать (или нет)?

Все магические методы  должны объявлены как public.
__get - будет выполнен при чтении данных из недоступных свойств.
__set - будет выполнен при записи данных в недоступные свойства.
__isset - будет выполнен при использовании isset() или empty() на недоступных свойствах.
__unset - будет выполнен при вызове unset() на недоступном свойстве.
__call - запускается при вызове недоступных методов в контексте объект.
__callStatic - запускается при вызове недоступных методов в статическом контексте. 

__get(), __set(), __isset(), __unset() - Первые четыре метода в нашем списке используются для перегрузки свойств объекта. Они позволяют определить, каким образом будет взаимодействовать внешний мир со свойствами, объявленными с модификатором видимости private или protected, либо вообще отсутствующими у объекта.Грозят потерей инкапсуляции. Примененимо при лжерефакторинге и попытки избавиться от сеттеров и геттеров. __call и __callStatic, выполняют похожую функцию, позволяя реализовать перегрузку методов. Они позволяют нам определить, как класс и его экземпляры отреагируют на попытки вызова неопределенных, защищенных или приватных методов. 

Задание 5
Опишите несколько структур данных из стандартной библиотеки PHP (SPL). Приведите примеры использования.

SplDoublyLinkedList - обеспечивает основные функциональные возможности двусвязного списка.
SplDoublyLinkedList::add — Добавляет/вставляет новое значение по указанному индексу
SplDoublyLinkedList::bottom — Получает узел, находящийся в начале двусвязного списка
SplDoublyLinkedList::__construct — Создает новый двусвязный список
SplDoublyLinkedList::count — Подсчитывает количество элементов в двусвязном списке
SplDoublyLinkedList::current — Возвращает текущий элемент массива
SplDoublyLinkedList::getIteratorMode — Возвращает режим итерации
SplDoublyLinkedList::isEmpty — Проверяет, является ли двусвязный список пустым
SplDoublyLinkedList::key — Возвращает индекс текущего узла
SplDoublyLinkedList::next — Перемещает итератор к следующему элементу
SplDoublyLinkedList::offsetExists — Проверяет, существует ли запрашиваемый индекс
SplDoublyLinkedList::offsetGet — Возвращает значение по указанному индексу
SplDoublyLinkedList::offsetSet — Устанавливает значение по заданному индексу $index в $newval
SplDoublyLinkedList::offsetUnset — Удаляет значение по указанному индексу $index
SplDoublyLinkedList::pop — Удаляет (выталкивает) узел, находящийся в конце двусвязного списка
SplDoublyLinkedList::prev — Перемещает итератор к предыдущему элементу
SplDoublyLinkedList::push — Помещает элемент в конец двусвязного списка
SplDoublyLinkedList::rewind — Возвращает итератор в начало
SplDoublyLinkedList::serialize — Сериализует хранилище
SplDoublyLinkedList::setIteratorMode — Устанавливает режим итерации
SplDoublyLinkedList::shift — Удаляет узел, находящийся в начале двусвязного списка
SplDoublyLinkedList::top — Получает узел, находящийся в конце двусвязного списка
SplDoublyLinkedList::unserialize — Десериализует хранилище
SplDoublyLinkedList::unshift — Вставляет элемент в начало двусвязного списка
SplDoublyLinkedList::valid — Проверяет, содержит ли узлы двусвязный список

SplStack - предоставляет основные функциональные возможности стека, реализованные с использованием двусвязного списка
SplStack::__construct — Создает новый стек, реализованный с использованием двусвязного списка
SplStack::setIteratorMode — Устанавливает режим итератора

SplQueue - предоставляет основные функциональные возможности очереди, реализованные с использованием двусвязного списка.
SplQueue::__construct — Создает новую очередь, реализованную с использованием двусвязного списка
SplQueue::dequeue — Удаляет элемент из очереди
SplQueue::enqueue — Добавляет элемент в очередь
SplQueue::setIteratorMode — Устанавливает режим итератора

Задание 6
Найдите все ошибки в коде:
*/
interface MyInt {
    public function funcI();
    private function funcP(); // интерфейс может иметь только публичные методы
} 
class A {
    protected prop1; // Неверное объявление без $
    private prop2; // Неверное объявление без $
    function funcA(){
       return $this->prop2; // Ничего не даст так как не объявлено значение переменной $prop2
    }
}
class B extends A {
    function funcB(){
       return $this->prop1; // Ничего не даст так как не объявлено значяение переменной $prop1
    }
}
class C extends B implements MyInt { // Нет метода funcI() объявленного в интерфейсе MyInt
    function funcB(){
       return $this->prop1; // Ничего не даст так как не объявлено значяение переменной $prop1
    }
    private function funcP(){
       return 123;
    }
}  
$b = new B(); // Ничего не даст так как не объявлено значяение переменной $prop1
$b->funcA(); 
$c = new C(); // Ошибка, в классе С Нет метода funcI() объявленного в MyInt
$c->funcI(); 
